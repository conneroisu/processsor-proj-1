"""Updater script that dynamically updates MARS and the toolflow from gitlab.

Author:
    Braedon Giblin <bgiblin@iastate.edu>

Date: 2022.02.12
"""

import subprocess
import pathlib
import json
import shutil
import os
import re
from collections import namedtuple
import zipfile
import io
import sys

sys.path.append("internal/testpy/requestslib")
import requests

#            G1: sp  g2:22  g2: 1  g3:2
#               V     V      V       V
V_STR_RE = re.compile(r"(sp|fa)([\d]+)\.(\d+)\.(\d+)")

JOB_ID_RE = re.compile(r"jobs/([\d]+)/")

        #/jobs/42/artifacts
MARS_P_TOK = "glpat-yK63EiHVCAZm9siY_sQP" # Private token, generated by Gitlab, read only
TF_P_TOK = "glpat-YadkW8HpfWW4oPd11y1y" # Private token, generated by Gitlab, read only
MARS_PRJ_ID = 3804 # Project ID, found on the project page of Gitlab
TF_PRJ_ID = 2302 # Project ID, found on the project page of Gitlab

mars_path = pathlib.Path('internal/Mars/MARS_CPRE381.jar').resolve()

class Updater():
    vers = namedtuple("vers", "term year major minor")
    MARS_REL_URL = "https://git.ece.iastate.edu/api/v4/projects/{}/releases".format(MARS_PRJ_ID)
    TF_REL_URL = "https://git.ece.iastate.edu/api/v4/projects/{}/releases".format(TF_PRJ_ID)
    MARS_URL = "https://git.ece.iastate.edu/api/v4/projects/{}".format(MARS_PRJ_ID)
    TF_URL = "https://git.ece.iastate.edu/api/v4/projects/{}".format(TF_PRJ_ID)
    mars_header = {"PRIVATE-TOKEN": MARS_P_TOK}
    tf_header = {"PRIVATE-TOKEN": TF_P_TOK}

    def __init__(self, force=False, toolflow=True):
        if toolflow:
            self.remote_tf_v = self.get_remote_tf_version()
            self.curr_tf_v = self.get_current_tf_version()
            
            if (not self.tf_version_cmp()):
                print("Toolflow update available")
                self.print_tf_vers()
                if (self.y_n_req("Would you like to update The toolflow?")):
                    self.download_tf()

        self.remote_mars_v = self.get_remote_mars_version() # This must be called first to update the MARS url

        if force: # CICD Hack... this allows us to force install the latest MARS for packaging the toolflow
            self.download_mars()

        self.curr_mars_v = self.get_current_mars_version()

        if (not self.mars_version_cmp()):
            print("MARS update available")
            self.print_mars_vers()
            if (self.y_n_req("Would you like to update MARS?")):
                self.download_mars()

    def mars_version_cmp(self):
        """ Compares the current version to the compared version of mars
        
        Returns:
            true if current is up to date, else false
        """
        curr_v = self.curr_mars_v
        remote_v = self.remote_mars_v

        if(int(remote_v.year) > int(curr_v.year)):
            return False
        elif(int(remote_v.year) ==  int(curr_v.year)):
            if((curr_v.term == "sp") and (remote_v.term == "fa")):
                return False
            else:
                if(int(remote_v.major) > int(curr_v.major)):
                    return False
                elif(int(remote_v.major) == int(curr_v.major)):
                    if(int(remote_v.minor) > int(curr_v.minor)):
                        return False
                    
                
        return True

    def tf_version_cmp(self):
        """ Compares the current version to the compared version of mars
        
        Returns:
            true if current is up to date, else false
        """
        curr_v = self.curr_tf_v
        remote_v = self.remote_tf_v

        if(int(remote_v.year) > int(curr_v.year)):
            return False
        elif(int(remote_v.year) ==  int(curr_v.year)):
            if((curr_v.term == "sp") and (remote_v.term == "fa")):
                return False
            else:
                if(int(remote_v.major) > int(curr_v.major)):
                    return False
                elif(int(remote_v.major) == int(curr_v.major)):
                    if(int(remote_v.minor) > int(curr_v.minor)):
                        return False
        return True

    def download_mars(self):
        print("Downloading Mars...")
        r = requests.get(self.MARS_URL, allow_redirects=True, headers=self.mars_header)
        z = zipfile.ZipFile(io.BytesIO(r.content)).extractall(path=mars_path.parent)
        print("Done.")

    def download_tf(self):
        print("Downloading Toolflow...")
        r = requests.get(self.TF_URL, allow_redirects=True, headers=self.tf_header)
        z = zipfile.ZipFile(io.BytesIO(r.content)).extractall(path="tf.tmp")
        print("Done.")
        print("Extracting Toolflow...")
        shutil.unpack_archive("tf.tmp/cpre381-toolflow.zip", "tf.tmp", "zip")
        print("Done.")
        print("Updating...")
        shutil.rmtree("internal")
        for f in pathlib.Path("tf.tmp/cpre381-toolflow").iterdir():
            if f.is_dir():
                shutil.copytree(str(f), "internal")
            else:
                try:
                    os.remove(f.name)
                except FileNotFoundError:
                    pass
                shutil.copyfile(str(f), f.name)
        shutil.rmtree("tf.tmp")
        os.chmod("./381_tf.sh", 0o755)
        print("Done.")
        print("Exiting...")
        exit(0)
      
    def y_n_req(self, question):
        while "the answer is invalid":
            reply = str(input(question+' (y/n): ')).lower().strip()
            if reply[0] == 'y':
                return True
            if reply[0] == 'n':
                return False
    
    def get_remote_mars_version(self):
        r = requests.get(self.MARS_REL_URL, headers=self.mars_header)
        name = r.json()[0]['name']
        mars =  r.json()[0]['assets']['links'][0]['direct_asset_url']

        v = V_STR_RE.search(name)
        j = JOB_ID_RE.search(mars)
        self.MARS_URL += "/jobs/{}/artifacts".format(j[1])
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_remote_tf_version(self):
        r = requests.get(self.TF_REL_URL, headers=self.tf_header)
        name = r.json()[0]['name']
        mars =  r.json()[0]['assets']['links'][0]['direct_asset_url']

        v = V_STR_RE.search(name)
        j = JOB_ID_RE.search(mars)
        self.TF_URL += "/jobs/{}/artifacts".format(j[1])
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor


    def get_current_mars_version(self):
        if (not mars_path.is_file()):
            if (self.y_n_req("MARS not installed. Would you like to download it?")):
                self.download_mars()
            else:
                print("MARS must be downloaded as {}".format(mars_path))
                exit(1)
        out = subprocess.check_output(
            ['java','-jar',mars_path,'v'],
            )
        v = V_STR_RE.search(out.decode("UTF-8"))
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_current_tf_version(self):
        if (os.path.exists("internal/version.txt")): 
            with open("internal/version.txt") as f:
                v = f.readlines()[0].strip()
        else:
            v = self.get_current_tf_from_git()
        v = V_STR_RE.search(v)
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_current_tf_from_git(self):
        try:
            return subprocess.check_output(
                ["git", "describe"]
            ).decode( "UTF8")
        except Exeception:
            return "sp22.0.0"
        
    def print_mars_vers(self):
        """Convenience function to print a version tuple

        """
        print("Current MARS version: {}{}.{}.{}".format(self.curr_mars_v.term,
                                self.curr_mars_v.year,
                                self.curr_mars_v.major,
                                self.curr_mars_v.minor))
        print("Available MARS version: {}{}.{}.{}".format(self.remote_mars_v.term,
                                  self.remote_mars_v.year,
                                  self.remote_mars_v.major,
                                  self.remote_mars_v.minor))
        
    def print_tf_vers(self):
        """Convenience function to print a version tuple

        """
        print("Current Toolflow  version: {}{}.{}.{}".format(self.curr_tf_v.term,
                                self.curr_tf_v.year,
                                self.curr_tf_v.major,
                                self.curr_tf_v.minor))
        print("Available Toolflow  version: {}{}.{}.{}".format(self.remote_tf_v.term,
                                  self.remote_tf_v.year,
                                  self.remote_tf_v.major,
                                  self.remote_tf_v.minor))
        
if __name__ == "__main__":
    u = Updater(force=True, toolflow=False)
    
    


